---
title: 面向对象和继承
date: 2016-12-28 18:44:20
categories: JavaScript
---

# 面向对象相关概念
**对象**：万物皆对象

**类**:对象的具体分类，例如人类

**实例**：人类中的具体某个人

## 面向对象的三大特征
- 封装
> 把实现一个功能的代码放在一个函数中封装起来，以后再想实现这个功能的时候，我们不需要重新的编写代码了，只需要执行对应的函数即可，我们把这种机制就称之为"函数的封装" -->低耦合高内聚:减少页面中的冗余代码,提高代码的重复使用率

- 继承
> 子类继承父类中的属性和方法

- 多态
> 当前方法的多种形态，在后台语言中，多态包含重载和重写

重载(Reload)：多个方法,方法名相同,参数的个数或者参数的类型不一样
重写(Rewrite)：子类重写父类的方法

-JS中如果函数名相同了,后面的会把前面的函数给覆盖掉,所以JS中不存在重载
- JS中的多态指的是一个方法的多种形态:一个方法,我们通过传递进来的参数值的不一样,实现不一样的功能

# 面向对象中的设计模式
## 单例模式
> 把描述同一个对象的方法放在同一个空间中，起到了分组作用，这样不同对象之间的属性，即使属性名一样，也不会冲突，我们把这种分组编写代码的模式叫做”单例模式“
> 其实就是一个对象，解决命名冲突的问题

### 最简单的单例模式
```js
var person1={
    name:'xy',
    age:25,
    fn:function(){
        console.log(this.name);
    }
}
var person2={
    name:'丫丫',
    age:19,
    fn:function(){
        console.log(this.name);
    }
}
console.log(person1.name);//"xy"
console.log(person2.name);//"丫丫"
```

这样的写法会暴露所有模块成员，内部状态可以被外部改写。

### 闭包实现
```
(function () {
    var a=1;
    function fn() {
        console.log(a);
    }
    window.onresize=fn;
})();
fn();//fn is not defined
```

以上写法，外界是获取不到fn函数，如果想要获取里面的属性和方法，有两种办法
- 把函数赋值给全局变量window   window.fn=fn
```
(function () {
    var a=1;
    function fn() {
        console.log(a);
    }
    window.fn=fn;
})();
fn();//1
```

- 函数里面return，函数外面定义一个变量接收
```js
var handleEvent=(function () {
    var a=1;
    function fn() {
        console.log(a);
    }
    return {
        fn:fn
    }
})();
handleEvent.fn();//1
```

单例模式也叫命名空间(namepSpace)，把person1或person2也叫做“命名空间”
单例模式属性函数之间的调用使用this就可以，这个this就是这个对象

**模块化开发**：
对于一个相对来说比较大的项目，需要多人协作的开发，我们一般会根据当前项目的需求划分成几个功能板块，每个人负责一部分，同时开发，最后把每个人的代码进行合并
```js
//菜单区域的操作
var menuRender = (function () {
    ...
})();

//日历区域的操作
var calendarRender = (function () {
    ...
})();

//比赛区域的操作
var matchRender = (function () {
    ...
})();
```

以上就是Javascript模块的基本写法。一般开发项目中，最常用的也是以上的这种单例模式，

## 工厂模式
单例模式虽然解决了分组的作用，但是不能实现批量的生产，属于手工作业模式，所有又产生了工厂模式
> 工厂模式:把实现同一个功能的代码放到一个函数当中，以后再想实现这个功能，不需要重新编写这些代码了，只需要执行当前的函数即可

工厂模式实现步骤：
- 在函数开始的阶段创建一个对象
- 中间的代码都是向这个对象添加属性
- 在函数结尾return这个对象
```js
function creatJsPerson(name,age){
    var obj={};
    obj.name=name;
    obj.age=age;
    obj.writeJs=function(){
        console.log("my name is"+this.name+'我会js啦！');
    };
    return obj;
}
var p1=creatJsPerson('张三',23);
var p2=creatJsPerson('李四',32);
console.log(p1);//Object {name: "张三", age: 23}
console.log(p2);//Object {name: "李四", age: 32}
```

## 构造函数模式
> 构造函数可以用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中，我们也可以创建自定义的构造函数，从而自定义对象类型的属性和方法

```
function CreatJsPerson(name,age){
    this.name=name;
    this.age=age;
    this.writeJs=function(){
        console.log("my name is"+this.name+',我会js啦！');
    }
}
var p1=new CreatJsPerson('李四',23);
var p2=CreatJsPerson("王五",43);//直接执行构造函数
console.log(p1);//CreatJsPerson {name: "李四", age: 23}
console.log(p2);//undefined
```

**new一个类，到底发生了什么**？
- 创建一个新的空对象
- 将this指针指向这个空对象
- 执行构造函数中的代码（为这个新对象添加属性或方法）
- 返回这个对象

注意:
- 在构造函数模式中，new Fn()执行，如果Fn不需要传递参数的话，后面的小括号可以省略
- 在构造函数模式中，浏览器会默认把我们的实例返回（返回的是一个对象数据类型）
- 如果手动返回：若返回的是基本数据类型的值，当前实例是不变的；返回的是引用数据类型的值，当前实例会被自己返回的值覆盖

## 原型模式
> 原型模式是为了解决公有属性和方法的放置问题

```js
function CreatJsPerson(name,age){
    this.name=name;
    this.age=age;
    this.writeJs=function(){
        console.log("my name is"+this.name+',我会js啦！');
    }
}
/*CreatJsPerson.prototype.getName=function () {//定义公有的方法，在原型上
    console.log(this.name);
};*/
CreatJsPerson.prototype={//这种写法导致constructor属性丢失
    constructor:CreatJsPerson,//要手动加上
    getName:function () {
        console.log(this.name);
    }
};
var p1=new CreatJsPerson('李四',23);
console.log(p1);//CreatJsPerson {name: "李四", age: 23}
```

- 函数定义结束就会天生自带一个属性叫prototype（原型），这个属性的值仍然是一个对象数据类型。并且这个属性值也天生自带两个属性，一个是constructor，另一个是__proto__，其中constructor的值是函数自己
- 任何一个实例天生自带一个属性__proto__，这个属性的值也是一个对象数据类型。这个值就是这个实例自己所属于的那个类的原型
```js
var fe1=new FE()
fe1.__proto__===FE.prototype
```

- 任何一个引用数据类型都天生自带一个__proto__,这个__proto属性永远都指向自己所属类的原型
- 任何一个引用数据类型都是Object的一个实例
- 批量设置==》把天生自带的原型重新赋值为一个新的对象，导致constructor丢失，导致再去打印实例的constructor时，直接在原型上获取不到了，通过原型的__proto__到Object的原型获取到constructor属性。
ps：实例的constructor属性至少是function Object(){}

# 函数的三种角色
- 普通函数  Fn()
- 构造函数  new Fn()
- 对象  Fn.xxx

```js
function Foo(){//刚开始不能确定它的身份
    getName = function(){console.log(1);};
    return this;
}
Foo.getName = function(){console.log(2);};//把Foo当做对象添加方法
Foo.prototype.getName = function(){console.log(3);};//Foo的原型上添加方法==》Foo是构造函数
var getName = function(){console.log(4);};
function getName(){console.log(5);};//当函数名和变量名重名，以变量的值为最终值

Foo.getName();//2  Foo此时是对象
getName();//4
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();3
getName();//1
```

# 面向对象中的继承
面向对象中，继承的方法（6种）：
- 原型继承
子类的公有，继承了父类的私有和公有
- call继承
子类的私有，继承了父类的私有
- 冒充对象继承
子类的私有，继承了父类的私有
- 混合式继承
子类的私有，继承了父类的私有；子类的公有，继承了父类的私有和公有
- 中间件继承
子类的公有，继承了父类的公有
- 寄生组合式继承
子类的私有，继承了父类的私有；子类的公有，继承了父类的公有

## 原型继承
- 让子类的原型指向父类的实例
- ===>子类的公有，继承了父类的私有和公有

```js
function Parent() {
    this.x=100;
}
Parent.prototype.getX=function () {
    console.log(this.x);
};
function Child() {}

//核心代码：
Child.prototype=new Parent;//子类的公有，继承了父类的私有和公有
Child.prototype.constructor=Child;

var child=new Child;
console.log(child);
```

## call继承
- 把父类当成普通函数执行，修改其中的this
- ==>子类的私有，继承了父类的私有

```js
function Parent() {
    this.x=100;
}
Parent.prototype.getX=function () {
    console.log(this.x);
};

//核心代码：
function Child() {
    Parent.call(this);//子类的私有，继承了父类的私有
}

var child=new Child;
console.log(child);
```

## 冒充对象继承
- 把父类实例化的结果进行遍历，把私有的都给子类一份
- ==>子类的私有，继承了父类的私有

```js
function Parent() {
    this.x=100;
}
Parent.prototype.getX=function () {
    console.log(this.x);
};

//核心代码：
function Child() {
    var obj=new Parent;
    for(var key in obj){
        if(obj.hasOwnProperty(key)){
            this[key]=obj[key];//子类的私有，继承父类的私有
        }
    }
}

var child=new Child;
console.log(child);
```

## 混合式继承
- call继承+原型继承
- ==>子类的私有，继承了父类的私有；子类的公有，继承了父类的私有和公有

```js
function Parent() {
    this.x=100;
}
Parent.prototype.getX=function () {
    console.log(this.x);
};

//核心代码：
function Child() {
    Parent.call(this);//子类的私有，继承父类的私有
}
Child.prototype=new Parent;//子类的公有，继承父类的私有和公有
Child.prototype.constructor=Child;

var child=new Child;
console.log(child);
```

## 中间件继承（不兼容）
- 子类的原型指向父类的原型
- ==>子类的公有，继承了父类的公有

```js
function Parent() {
    this.x=100;
}
Parent.prototype.getX=function () {
    console.log(this.x);
};
function Child() {}

//核心代码：
Child.prototype=Parent.prototype;//子类的公有，继承父类的公有
Child.prototype.constructor=Child;

var child=new Child;
console.log(child);
```

## 寄生组合式继承（不兼容）
- call继承+Object.create()
- 为了解决混合继承的缺陷
- ==>子类的私有，继承了父类的私有；子类的公有，继承了父类的公有

```js
function Parent() {
    this.x=100;
}
Parent.prototype.getX=function () {
    console.log(this.x);
};

//核心代码：
function Child() {
    Parent.call(this);//子类的私有，继承父类的私有
}
// Child.prototype=Object.create(Parent.prototype);//子类的公有，继承父类的公有（Object.create不兼容）
//自己写兼容的方法：
function createObject(obj) {
    //相当于在Parent和Child中间又加了一层，这样修改Child的原型时，就不会影响到Parent
    function Fn() {}
    Fn.prototype=obj;
    return new Fn;
}
Child.prototype=createObject(Parent.prototype);
Child.prototype.constructor=Child;

var child=new Child;
console.log(child);
```