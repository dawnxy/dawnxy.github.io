---
title: 正则及实战应用
date: 2016-10-22 18:44:20
categories: JavaScript
---

什么是正则表达式？
> 正则表达式(regular expression)描述了一种字符串匹配的模式
有以下作用：

- 验证：用来检查一个串是否含有某种子串
- 捕获：将匹配的子串做替换或者从某个串中取出符合某个条件的子串等

正则表达式由两种基本字符类型组成：原义（正常）文本字符和元字符
# 正则的创建
- 字面量创建
```js
var reg=/a/;
```

- 实例创建
参数1：是字符串（就是字面量的方式放在两个斜杠中的那些字符）
参数2：是修饰符，也是一个字符串
```js
var reg=new RegExp('a','g');
```

**字面量创建和实例创建的区别**：
使用字面量方式不可以把变量添加到正则中

注意：
- 只要正则中需要引入变量，那么只能使用实例的创建方式
- 如果在实例方式创建正则使用\d等特殊元字符，还需要转义一次（在前面添加一个"\"）

# 正则的元字符
> 元字符（Metacharacter）是拥有特殊含义的字符

## 常用元字符
| 字符      |    描述 |
| :-------- |  :--: |
| \d  | 0-9之间的数字 |
| \D  | 除了\d |
| \w     |   数字、字母、下划线，即：0-9 a-z A-Z _ |
| \W      |    除了\w |
| \s      |   空(空字符串，空格，多个空格)  |
| \S      |   除了\s  |
| \n    |换行 |
| \b   | 边界。不一定是字符串的开头或者结尾，空格也是边界，百分号%两边也是边界 |
| ^ | 以什么开始 |
| $   | 以什么结束 |
| . | 任意字符，除了\n和空字符串 |
| \   | 转义，一般用来转特殊意思的元字符 |
| \ .   | 把这个.从任意字符转为.本身 |

## 限定符/量词
| 字符      |    描述 |
| :-------- |  :--: |
| ?  | 出现0-1次==》可以有，可以没有 |
| +  | 出现1-多次==》至少出现1次 |
| *     |   出现0-多次==》可以不出现，也可以出现无数次 |
| {n}      |    出现n次 |
| {n,}      |   出现n-多次|
| {n,m}      |   出现n-m次  |

## 修饰符
| 字符      |    描述 |
| :-------- |  :--: |
| g  | 全局匹配 |
| i  | 忽略大小写 |
| m  | 多行匹配 |

## 方括号
> 方括号用于查找某个范围内的字符

| 字符      |    描述 |
| :-------- |  :--: |
| [abc]  | 查找方括号之间的任何字符 |
| [^abc]  | 查找不在方括号之间的字符 |
| [a-h]  | 查找a-h之间的字符 |
注意：
- [+-] 代表+或者-本身
- [.] 代表.本身

- [\d]   仍然代表0-9中间的数字
- [\s]   代表空格或制表符
- [\w]   代表字母、数字、下划线，即：[0-9a-zA-Z_]

## 分组
### ()
> 在正则表达式中，()不仅仅有改变优先级的作用，还有分组的作用
只要存在了分组，使用exec方法的捕获结果也会发生改变，第一项仍然是最大的正则捕获到的内容。从第二项开始，依次是正则中分组所对应匹配到的内容

```js
var reg=/(\d{2})(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(\d{3})(\d|x)/;
var str="622301199110043521";
var res=reg.exec(str);
console.log(res);//["622301199110043521", "62", "23", "01", "1991", "10", "04", "1", index: 0, input: "622301199110043521"]
```

### ?:
> ?:代表这个分组只匹配不捕获，其实也就是取消/破坏分组，只具有改变优先级的作用

用法：?:放在分组里的开头
```js
var reg=/(\d+)/;
console.log(reg.exec('123abc'));//["123", "123", index: 0, input: "123abc"]

//只匹配不捕获
var reg=/(?:\d+)/;
console.log(reg.exec('123abc'));//["123", index: 0, input: "123abc"]
```

### 分组的引用
> 只要正则中出现了分组，那么就可以使用\n来引用这个分组所匹配到的内容

/(\w)(\d)\1/  \1跟第一个分组完全相同
```js
var reg=/(\w)(\d)\1/g;
console.log(reg.exec('3z3z'));//["z3z", "z", "3", index: 1, input: "3z3z"]
```

# 正则的验证
## test()
> 检索字符串中的指定值

**用法**：[reg].test([str])
**返回值**：匹配返回true，否则返回false

1、非空验证
`/^\s*$/`
```js
var reg=/^\s*$/;
console.log(reg.test(""));//true
console.log(reg.test(" a"));//false
```

2、有效数字验证
`/^[+-]?\d+(\.\d+)?$/`
```js
var reg=/^[+-]?\d+(\.\d+)?$/;
console.log(reg.test("1.a"));//false
console.log(reg.test("1"));//true
```

3、邮箱验证
`/^\w{1,26}@[0-9a-zA-Z]{1,20}(\.[a-z]{2,3}){1,2}$/`
```js
var reg=/^\w{1,26}@[0-9a-zA-Z]{1,20}(\.[a-z]{2,3}){1,2}$/;
console.log(reg.test("asd@sd.com"));
```

# 正则的捕获
正则捕获包括两大类：
RegExp对象的方法：
- exec()

String对象的方法：
- match()
- replace()

## RegExp对象的方法
### exec()
> 检索字符串中的指定值

**用法**：[reg].exec([str])
**返回值**：是一个数组：["捕获到的内容","捕获开始的索引位置","捕获的那个整个字符串"]。如果捕获当次没有捕获到，结果返回null
- reg.lastIndex属性是负责下次正则从哪个位置开始匹配或者捕获
- 如果没有全文g那么lastIndex属性的值一直都是0，每次都从开头开始匹配

```js
var reg=/\d+/;
var str="zhufeng2015zhufeng2016";
//第一次捕获
var res=reg.exec(str);
console.log(res);//["2015", index: 7, input: "zhufeng2015zhufeng2016"]

//第二次捕获(重头开始捕获)
var res=reg.exec(str);
console.log(res);//["2015", index: 7, input: "zhufeng2015zhufeng2016"]

//加了全局匹配g后
var reg=/\d+/g;
//第一次捕获
var res=reg.exec(str);
console.log(res);//["2015", index: 7, input: "zhufeng2015zhufeng2016"]
console.log(reg.lastIndex);//11
//第二次捕获
var res=reg.exec(str);
console.log(res);//["2016", index: 18, input: "zhufeng2015zhufeng2016"]
console.log(reg.lastIndex);//22
//第三次捕获
var res=reg.exec(str);
console.log(res);//null
console.log(reg.lastIndex);//0
//第四次捕获
var res=reg.exec(str);
console.log(res);//["2015", index: 7, input: "zhufeng2015zhufeng2016"]
console.log(reg.lastIndex);//11
```

## String对象的方法
### match()
> 找到一个或多个正则表达式的匹配。

**用法**：[str].match([substr]/[reg])
**返回值**：仍然是一个数组：["捕获到的内容","捕获开始的索引位置","捕获的那个整个字符串"]。如果捕获当次没有捕获到，结果返回null
- 在正则中不包含g，和exec完全相同，也是每次从开始位置捕获
- 在正则中包含g，一次能够把所有字符串中符合要求的全部捕获到
- 但是match方法在存在g的时候，虽然一次性能够把所有的符合要求的全部捕获到，然而那个记录捕获索引位置的index属性就不存在了，只有捕获到的分组内容组成的数组

```js
var reg=/\d+/g;
var str="zhufeng2015zhufeng2016";
console.log(str.match(reg));//["2015", "2016"]
```

如何用exec模拟match方法？
```js
var reg=/\d+/g;//如果没有g会死循环
var str="zhufeng2015zhufeng2016";
var res=reg.exec(str);
var ary=[];
while(res){//reg.exec(str)为null时，停止循环
    ary.push(res[0]);
    res=reg.exec(str);
}
console.log(ary);//["2015", "2016"]
```

### replace()
> 替换与正则表达式匹配的子串

**用法**：str.replace([substr]/[reg],[replaceStr]/[function])
**返回值**：匿名函数执行的返回值
- 匿名函数执行多少次取决于正则成功匹配到的次数
- 正则成功匹配到的内容用函数的返回值来替换
- 匿名函数的arguments：[正则本次匹配的内容，分组1，....分组n,index,input]

```js
var str="zhufeng2015zhufeng2016";
var reg=/\d+/g;
var res=str.replace(reg,function(item,index,str){
    //console.log(item,index,str);//2015 7 zhufeng2015zhufeng2016
    //console.log(arguments);//["2015", 7, "zhufeng2015zhufeng2016"]  ["2016", 18, "zhufeng2015zhufeng2016"]
    //return "珠峰";//zhufeng珠峰zhufeng珠峰
    return index;
});
console.log(res);//zhufeng7zhufeng18
```

# 支持正则的其他方法
String对象上有两个方法也支持正则:
- search()
- split()

## search()
> 检索与正则表达式相匹配的值。

**语法**：str.search([substr]/[reg])
**返回值**：找到返回对应字符的索引； 找不到返回-1；
```js
var str='abc今年28岁';
var res=str.search(/\d/);
console.log(res);//5
```

## split()
> 把字符串分割为字符串数组。

**语法**：str.split([separator]/[reg])
```js
var str='a    b c de';
var res=str.split(/\s+/);
console.log(res);//["a", "b", "c", "de"]
```

# 正则的特性
- 懒惰：每次尽可能少的匹配
  破坏懒惰：加修饰符g
- 贪婪：每次尽可能多的匹配
  破坏贪婪：量词后面加?

# RegExp.$n
> 最后一个正则实例分组捕获的结果会存储在RegExp的静态属性$1-$9中。也就是说当正则表达式中的分组超过9个的时候，RegExp最多只保留9个。

```js
var reg=/(\d{2})(\d{2})(\d{2})(\d{4})(\d{2})(\d{2})(\d{3})(\d|x)/;
var str="622301199110043521";
var res=reg.exec(str);
console.log(RegExp.$1);//62
console.log(RegExp.$4);//1991
```

# 正向预查与负向预查
`?=`  只是一个肯定的限定条件，并不占位  (?=x|y)    必须是x或者y
`?!`  只是一个否定的限定条件，并不占位  (?!x|y)    不能是x或者y
**案例：将数字转为千分符**
**方案一**：
正向预查 将索引倒过来
```js
var str="123456789";//====>12,345,678
//"12345678"==>[1,2,3,4,5,6,7,8]==>[8,7,6,5,4,3,2,1]==>"87654321"
//把"876"用"876,"替换
var reg=/(\d{3})(?!$)/g;//在匹配的时候，右侧不能是$
var str2=str.split("").reverse().join("").replace(reg,function () {
    //arguments:[regRes,$1,input,index]
    return arguments[0]+",";
}).split("").reverse().join("");
console.log(str2);
```

**方案二**：
正向预查 连续出现3个数字1到多次，并且每次必须查到结尾
```js
//连续出现3个数字1到多次，并且每次必须查到结尾
var str="12345678";
var reg=/(\d{1,2})(?=(\d{3})+$)/g;
var res=str.replace(reg,"$1,");
console.log(res);
```

**方案三**：
根据索引替换
```js
var str="12345678";
//==>12,345,678
//当索引值为1和4的时候用自己+“,”代替
var reg=/\d(?!$)/g;
var res=str.replace(reg,function (item,index) {
    //item: 1 2,3 4 5,6 7 8
    //index:0 1 2 3 4 5 6 7  ==>将索引1和索引4挑出来
    //如何将item的索引倒过来？
    //str.length:8
    //str.length-1-index
    //====>7 6 5 4 3 2 1 0  ==》将6和3挑出来
    if((str.length-1-index)%3==0){
        return item+",";
    }else{
        return item;
    }
})
console.log(res);
```

# ?的用法总结
-  ?本身
-  \d?  量词
-  (?:\d+) 匹配不捕获
-   ?=  正向预查
-   ?!  负向预查