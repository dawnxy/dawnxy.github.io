---
title: 内存释放
date: 2016-12-22 18:44:20
categories: JavaScript
---

对于其他语言来说，如C,C++,需要开发者手动的来跟踪内存，而JS的垃圾回收机制使得JS开发人员无需再关系内存的情况，所有的内存分配以及回收都会由垃圾回收器自动完成，执行环境会对执行过程中占有的内存负责。其原理就是找出那些不在被使用的变量，然后释放其所占有的内存。回收器一般是按照固定的时间间隔或者预设的时间进行处理的。

常见的垃圾回收机制：
- 标记清除
标记清除简单的来说就是给各个变量名打上 YES or NO的标签以供JS引擎进行处理（当然打什么标签自己理解即可）。在和执行上下文类似的的环境中当变量名称进入环境的时候，那么变量会被打上 YES。一般来说是绝对不会释放被打上 YES 标签的变量内存的，一旦变量在出了该环境时，变会被打上 NO 标签（和作用域貌似有点像），JS引擎会在一定时间间隔或者设置的时间来进行扫描，对NO标签的进行剔除以释放其内存。
- 引用计数
我们开个内存，当我们引用了它，就在内存中记录一个数,增加一个引用浏览器就把这个数+1，减少一个引用，浏览器就把这个数-1...当减到零的时候浏览器就把这个内存释放了;但是有些情况下(尤其是IE)记着记着就弄乱了，内存就不能释放了-->浏览器的内存泄露

除了一些极老版本的IE，目前市面上的JS引擎基本采用标记清除来除了垃圾回收。但是需要注意的是IE中的DOM由于机制问题，是采用了引用计数的方式，所以会有循环引用的问题

解决方法其实也很简单，当所有的代码完毕末尾处只需要对变量进行 null 赋值即可。

# 堆内存释放
引用类型在定义的时候首先都会开辟一个堆内存，堆内存有一个引用的地址，如果外面有变量或者对象属性等知道了这个地址，我们就说这个内存被占用了，就不能销毁了。
我们想要让堆内存释放/销毁，只需要把所有引用它的变量或者对象属性主动赋值为null即可，如果当前的堆内存没有任何东西被占用了，那么浏览器会在空闲的时候把它销毁。

# 栈内存释放
全局作用域：只有当页面关闭的时候，才会销毁
私有作用域：只有当函数执行时才会产生私有作用域
一般情况下，函数执行会形成一个新的私有的作用域，当私有作用域当中的代码执行完成后，当前作用域都会主动进行释放和销毁，但是还是存在特殊情况，当前私有作用域中的部分内存被作用域以外的东西占用了，那么当前这个作用域就不能销毁了
- 函数执行返回了一个引用数据类型的值，并且在函数的外面被一个变量或对象的属性所占用，这种情况下，一般形成的私有作用域都不会被销毁
```js
function fn() {
    var num=100;
    return function () {
    }
}
var f=fn();//fn执行结果是引用数据类型，被变量f占用，所以形成的私有作用域不能被销毁
document.body.xxx=fn();//fn执行结果是引用数据类型，被body对象的xxx属性占用，所以形成的私有作用域也不能被销毁
```

- DOM对象的事件属性占用函数执行之后的返回的引用数据类型值，那么也符合作用域不被释放的情况(第一种情况的特殊情况)
```js
div1.onclick = (function (){
    var num=0;//num=1 num=2 num=3 num=4....  因为这个作用域不被释放，所以num的值也被保留下来了
    return function (){
        num++;
        console.log(num);//1 2 3 4 ....
    }
})();
方法二（推荐）：
;(function (num){
    div1.onclick = function (){//也是作用域不被释放的情况（div1.onclick可以理解为全局下对象的属性）
        num++;
        console.log(num);
    }
})(0);
```

- 下述情况属于不立即销毁：函数执行返回的函数立刻执行，所以暂时不销毁，但是当返回的值执行完成后，浏览器会在空闲的时候把它销毁
```js
function fn() {
    var num=100;
    return function () {
    }
}
fn()();//首先执行一个fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再次执行
```

# 内存释放综合实例
```js
function fn(m){
    return function(n){
        console.log(n+m++);
    }
}
var f1=fn(10);//fn第一次执行，形成一个私有作用域
f1(12);//22  作用域不释放
f1(13);//24  作用域不释放
var f2=fn(13);//fn第二次执行，形成一个新的私有作用域
f2(12);//25  作用域不释放
f2(13);//27  作用域不释放
fn(12)(13);//25   fn第三次执行，形成一个新的私有作用域，作用域暂时不释放，执行完成后释放
fn(12)(13);//25   fn第四次执行，形成一个新的私有作用域，作用域暂时不释放，执行完成后释放
```

注：函数每次执行都会形成一个新的私有作用域，而这些作用域之间没有任何关系。